[{"title":"js闭包测试","date":"2016-12-24T05:00:38.000Z","path":"2016/12/24/js闭包测试/","text":"闭包（closure） 当内部函数在定义它的作用域的外部被引用时,就创建了该内部函数的一个闭包。在这种情况下，我们称既不是内部函数局域变量，也不是其参数的变量为自由变量,称外部函数的调用环境为封闭闭包的环境。从本质上讲，如果内部函数引用了位于外部函数中的变量，相当于授权该变量能够被延迟使用。因此，当外部函数调用完成后，这些变量的内存不会被释放，因为闭包任然需要使用他们。 12345678910111213141516171819function foo()&#123; var secret = \"secret\" //\"闭包内的函数\" 可以访问上面的secret变量,而secret对外部作用域却是隐蔽的 return &#123; get_secret:function () &#123; //定义接口来访问 secret 变量 return secret; &#125;, new_secret:function (new_secret)&#123; secret = new_secret; &#125; &#125; &#125; console.log(foo().new_secret(2)); console.log(foo().get_secret()); 上面就创建了一个闭包,但是闭包的对象是指什么呢 函数foo 还是 secret 呢…不知道了","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]